```{python}
#| label: exercise3-q1
import pathlib
output_path = pathlib.Path("data/output")
output_path.mkdir(parents=True, exist_ok=True)
csv_file = output_path / "bpe_before_geoloc.csv"

bpe_enriched = bpe_enriched.with_columns(pl.col('adresse').str.replace(',', ' '))

(
bpe_enriched
    .select(['adresse', 'DEPCOM', 'nom_commune'])
    .write_csv(csv_file)
)
```

```{python}
import io

headers = {
    'accept': 'text/csv',
}

files = [
    ('indexes', (None, 'address')),
    ('indexes', (None, 'poi')),
    ('data', (str(csv_file), open(csv_file, 'rb'), 'text/csv')),
    ('citycode', (None, 'DEPCOM')),
    ('columns', (None, 'adresse'))
]

response = requests.post(
        "https://data.geopf.fr/geocodage/search/csv/",
        headers=headers,
        files=files
    )

bpe_loc = pl.read_csv(io.StringIO(response.text))

```

::: {.content-visible when-profile="fr"}
Les géolocalisations obtenues prennent cette forme
:::

::: {.content-visible when-profile="en"}
The obtained geolocations take this form
:::

```{python}
bpe_loc.head(2)
```

::: {.content-visible when-profile="fr"}
En enrichissant les données précédentes, cela donne:
:::

::: {.content-visible when-profile="en"}
By enriching the previous data, this gives:
:::

```{python}
#| label: exercise3-q2
bpe_loc = bpe_loc.select(['adresse', 'DEPCOM', 'nom_commune', 'result_score', 'latitude', 'longitude']).cast(pl.String)
bpe_enriched_geocoded = (
  bpe_enriched
  .join(bpe_loc, on = ['DEPCOM','adresse', 'nom_commune'], suffix = "_ban")
  .cast({"latitude": pl.Float64, "latitude_ban": pl.Float64, "longitude": pl.Float64, "longitude_ban": pl.Float64})
)

bpe_enriched_geocoded.head(2)
```

::: {.content-visible when-profile="fr"}
On peut vérifier que la géolocalisation ne soit pas trop délirante en comparant avec les longitudes et latitudes de l'annuaire de l'éducation ajouté précédemment:
:::

::: {.content-visible when-profile="en"}
We can check that the geolocation is not too off by comparing it with the longitudes and latitudes of the education directory added earlier:
:::

```{python}
(
    bpe_enriched_geocoded
    .select(["NOMRS", "nom_commune", "latitude", "latitude_ban", "longitude", "longitude_ban"])
    .sample(5)
)
```

::: {.content-visible when-profile="fr"}
Sans rentrer dans le détail, les positions semblent très similaires à quelques imprécisions près.
:::

::: {.content-visible when-profile="en"}
Without going into detail, the positions seem very similar, with only minor inaccuracies.
:::

```{python}
#| label: exercise3-q3
bpe_enriched_geocoded = bpe_enriched_geocoded.drop_nulls(subset=["longitude_ban","latitude_ban"])

bpe_enriched_geocoded = gpd.GeoDataFrame(
    bpe_enriched_geocoded.to_pandas(),
    geometry=gpd.points_from_xy(
      bpe_enriched_geocoded['longitude_ban'],
      bpe_enriched_geocoded['latitude_ban']
      ),
    crs="EPSG:4326"
)

```

::: {.content-visible when-profile="fr"}
Pour profiter de nos données enrichies, on peut faire une carte. Pour ajouter un peu de contexte à celle-ci, on peut mettre un fond de carte des communes en arrière plan. Celui-ci peut être récupéré avec `cartiflette`:
:::

::: {.content-visible when-profile="en"}
To make use of our enriched data, we can create a map. To add some context to it, we can place a background map of the municipalities. This can be retrieved using `cartiflette`:
:::


```{python}
#| echo: true
#| label: carti-download
from cartiflette import carti_download
shp_communes = carti_download(
  crs = 4326,
  values = ["31"],
  borders="COMMUNE",
  vectorfile_format="topojson",
  filter_by="DEPARTEMENT",
  source="EXPRESS-COG-CARTO-TERRITOIRE",
  year=2022
)
shp_communes.crs = 4326
```

::: {.content-visible when-profile="fr"}
Représentées sur une carte, cela donne la carte suivante:
:::

::: {.content-visible when-profile="en"}
Represented on a map, this gives the following map:
:::

```{python}
#| label: cartiflette-map
import folium
from folium.plugins import MarkerCluster
import geopandas as gpd

department_border = shp_communes.dissolve(by="INSEE_DEP")
city_borders = shp_communes.copy()

longitude = bpe_enriched_geocoded.geometry.x.iloc[0]
latitude = bpe_enriched_geocoded.geometry.y.iloc[0]
m = folium.Map(location=[latitude, longitude], zoom_start=10)

# Add department border (black, bold)
folium.GeoJson(
    data=department_border,
    style_function=lambda x: {
        "fill": False,
        "color": "black",
        "weight": 3  # Bold border
    }
).add_to(m)

# Add city borders (blue, thin)
folium.GeoJson(
    data=city_borders,
    style_function=lambda x: {
        "fill": False,
        "color": "blue",
        "weight": 1  # Thin border
    }
).add_to(m)

# Initialize the MarkerCluster
marker_cluster = MarkerCluster().add_to(m)

def generate_popup(row):
    # Initialiser le contenu avec le nom de l'école
    popup_content = f"<b>Nom:</b> {row['NOMRS']}<br>"

    # Ajouter "Ecole élémentaire" avec une icône ✅️ ou ❌️ selon la valeur
    ecole_element_status = "✅️" if row.get('Ecole_elementaire', False) else "❌️"
    popup_content += f"<b>Ecole élémentaire:</b> {ecole_element_status}<br>"

    # Ajouter "Nombre d'élèves" si disponible
    if not pd.isnull(row.get('Nombre_d_eleves')):
        popup_content += f"<b>Nombre d'élèves:</b> {row['Nombre_d_eleves']}<br>"

    # Ajouter "Voie générale" si disponible
    if not pd.isnull(row.get('Voie_generale')):
        popup_content += f"<b>Voie générale:</b> {row['Voie_generale']}<br>"

    # Ajouter "Voie technologique" si disponible
    if not pd.isnull(row.get('Voie_technologique')):
        popup_content += f"<b>Voie technologique:</b> {row['Voie_technologique']}<br>"

    return popup_content


# Add GeoDataFrame points to the MarkerCluster
for _, row in bpe_enriched_geocoded.iterrows():
    # Create the popup content
    popup_content = generate_popup(row)

    popup = folium.Popup(popup_content, max_width=300)

    # Add the marker to the cluster
    folium.Marker(
        location=[row.geometry.y, row.geometry.x],  # Extract latitude and longitude
        popup=popup,
        icon=folium.Icon(color="blue", icon="info-sign")
    ).add_to(marker_cluster)

# Display the map inline (optional for Jupyter Notebooks)
m
```
